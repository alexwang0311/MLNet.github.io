@page "/"

@using System.Runtime.InteropServices
@using MLNetOnGithub.Components.Chat
@using Microsoft.JSInterop
@using System.Net.Http.Headers
@using System.Text

@using System.Net.Http
@inject HttpClient HttpClient
@inject IJSRuntime JS

<PageTitle>MLNet.github.io</PageTitle>

<InputFile OnChange="@LoadFiles" />
<button @onclick="Download">start</button>
@if (isDownloading)
{
    <h2>Waiting</h2>
}
<Chat></Chat>

@code {
    [DllImport("main")]
    static extern int run(string text);

    private Byte[] bytes { get; set; }

    private Boolean isDownloading = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var jsInProcess = (IJSInProcessRuntime)JS;
            try
            {
                await jsInProcess.InvokeVoidAsync("Module.FS_unlink", "gpt-2.bin");
                await jsInProcess.InvokeVoidAsync("getBuffer", bytes);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }
    }

    protected async Task Download()
    {
        isDownloading = true;
        //bytes = await HttpClient.GetByteArrayAsync("model/ggml-model.bin");
        var jsInProcess = (IJSInProcessRuntime)JS;
        await jsInProcess.InvokeVoidAsync("Module.FS_createDataFile", "/", "gpt-2.bin", bytes, true, true);
        await Task.Run(() => run("Four score and seven years ago")).ConfigureAwait(false);
        isDownloading = false;
    }

    private Byte[] ReadToEnd(Stream stream)
    {
        long originalPosition = 0;

        if (stream.CanSeek)
        {
            originalPosition = stream.Position;
            stream.Position = 0;
        }

        try
        {
            byte[] readBuffer = new byte[4096];

            int totalBytesRead = 0;
            int bytesRead;

            while ((bytesRead = stream.Read(readBuffer, totalBytesRead, readBuffer.Length - totalBytesRead)) > 0)
            {
                totalBytesRead += bytesRead;

                if (totalBytesRead == readBuffer.Length)
                {
                    int nextByte = stream.ReadByte();
                    if (nextByte != -1)
                    {
                        byte[] temp = new byte[readBuffer.Length * 2];
                        Buffer.BlockCopy(readBuffer, 0, temp, 0, readBuffer.Length);
                        Buffer.SetByte(temp, totalBytesRead, (byte)nextByte);
                        readBuffer = temp;
                        totalBytesRead++;
                    }
                }
            }

            byte[] buffer = readBuffer;
            if (readBuffer.Length != totalBytesRead)
            {
                buffer = new byte[totalBytesRead];
                Buffer.BlockCopy(readBuffer, 0, buffer, 0, totalBytesRead);
            }
            return buffer;
        }
        finally
        {
            if (stream.CanSeek)
            {
                stream.Position = originalPosition;
            }
        }
    }

    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        var buffer = new byte[e.File.Size];
        await Task.Delay(1);
        await e.File.OpenReadStream(Int64.MaxValue).ReadAsync(buffer);
        bytes = buffer;
    }
}